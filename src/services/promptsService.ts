import {
  collection,
  doc,
  addDoc,
  updateDoc,
  deleteDoc,
  getDocs,
  getDoc,
  query,
  where,
  orderBy,
  limit,
  onSnapshot,
  serverTimestamp,
  increment,
  Timestamp,
  writeBatch
} from 'firebase/firestore';
import { db } from '../firebase';

// ============================================
// Types
// ============================================

export interface PromptField {
  id: string;
  label: string;           // "××§×¦×•×¢"
  placeholder: string;     // "××ª××˜×™×§×”, ×¢×‘×¨×™×ª..."
  type: 'text' | 'select' | 'number';
  options?: string[];      // for type=select
  required: boolean;
}

export interface Prompt {
  id: string;
  title: string;
  description: string;
  category: string;
  subcategory: string;
  promptTemplate: string;  // Text with {{placeholders}}
  fields: PromptField[];
  targetTools: string[];   // ['ChatGPT', 'Claude', 'Gemini']
  tips?: string;

  // Creator info
  createdBy: string | null;  // null = auto-generated
  creatorName: string;
  createdAt: Timestamp;
  isAutoGenerated: boolean;

  // Stats
  usageCount: number;
  averageRating: number;
  ratingCount: number;

  // Status
  status: 'active' | 'pending' | 'rejected';

  // Featured
  isFeatured?: boolean;
  featuredAt?: Timestamp;
}

export interface PromptRating {
  id?: string;
  promptId: string;
  userId: string;
  userName: string;
  rating: number;          // 1-5
  comment?: string;
  createdAt: Timestamp;
}

export interface TeacherStats {
  odUseri: string;
  promptCount: number;
  averageRating: number;
  totalRatings: number;
  isRecommended: boolean;  // 4.5+ avg and 5+ prompts
}

// ============================================
// Categories - Specific, not general
// ============================================

export const PROMPT_CATEGORIES = [
  {
    id: 'exams',
    name: '×™×¦×™×¨×ª ××‘×—× ×™×',
    icon: 'ğŸ“',
    subcategories: [
      '××‘×—×Ÿ ×¨×‘-×‘×¨×™×¨×”',
      '××‘×—×Ÿ ×¤×ª×•×—',
      '×‘×•×—×Ÿ ××”×™×¨ (5 ×“×§×•×ª)',
      '××‘×—×Ÿ ××•×ª×× ×œ×ª×œ××™×“×™× ×¢× ×œ×§×•×™×•×ª'
    ]
  },
  {
    id: 'lessons',
    name: '×”×›× ×ª ×©×™×¢×•×¨×™×',
    icon: 'ğŸ“š',
    subcategories: [
      '×¤×ª×™×—×ª ×©×™×¢×•×¨ ××¢× ×™×™× ×ª',
      '×¡×™×›×•× ×©×™×¢×•×¨',
      '×©×™×¢×•×¨ ××‘×•×¡×¡ ×—×§×¨',
      '×©×™×¢×•×¨ ×”×¤×•×š (Flipped)'
    ]
  },
  {
    id: 'feedback',
    name: '××©×•×‘ ×œ×ª×œ××™×“×™×',
    icon: 'ğŸ’¬',
    subcategories: [
      '××©×•×‘ ×¢×œ ×¢×‘×•×“×” ×›×ª×•×‘×”',
      '××©×•×‘ ××¢×•×“×“ ×œ×ª×œ××™×“ ××ª×§×©×”',
      '××©×•×‘ ×œ×ª×œ××™×“ ××¦×˜×™×™×Ÿ',
      '××©×•×‘ ×œ×”×•×¨×™×'
    ]
  },
  {
    id: 'activities',
    name: '××©×—×§×™× ×•×¤×¢×™×œ×•×™×•×ª',
    icon: 'ğŸ®',
    subcategories: [
      '××©×—×§ ×›×™×ª×ª×™',
      '×ª×—×¨×•×ª ×§×‘×•×¦×ª×™×ª',
      '×—×™×“×•×Ÿ',
      '×¤×¢×™×œ×•×ª ×©×™×ª×•×¤×™×ª'
    ]
  },
  {
    id: 'adaptations',
    name: '×”×ª×××•×ª ××™×©×™×•×ª',
    icon: 'ğŸ¯',
    subcategories: [
      '×¤×™×©×•×˜ ×˜×§×¡×˜',
      '×”×¢×©×¨×” ×œ×ª×œ××™×“ ××¦×˜×™×™×Ÿ',
      '×”×ª×××” ×œ×“×™×¡×œ×§×¦×™×”',
      '×ª×¨×’×•× ×œ×¢×¨×‘×™×ª'
    ]
  },
  {
    id: 'content',
    name: '×™×¦×™×¨×ª ×ª×•×›×Ÿ',
    icon: 'âœ¨',
    subcategories: [
      '×¡×™×¤×•×¨ ×œ×™××•×“×™',
      '×©×™×¨ ×¢×œ × ×•×©×',
      '×“×™××œ×•×’ ×œ×”××—×©×”',
      '×× ×œ×•×’×™×” ×œ×”×¡×‘×¨ ××•×©×’'
    ]
  },
  {
    id: 'management',
    name: '× ×™×”×•×œ ×›×™×ª×”',
    icon: 'ğŸ‘¥',
    subcategories: [
      '×ª×¡×¨×™×˜ ×œ×©×™×—×” ×¢× ×”×•×¨×”',
      '×˜×™×¤×•×œ ×‘×‘×¢×™×™×ª ××©××¢×ª',
      '×”× ×¢×ª ×ª×œ××™×“ ×× ×•×ª×§',
      '×‘× ×™×™×ª ×—×•×–×” ×›×™×ª×ª×™'
    ]
  },
  {
    id: 'assessment',
    name: '×”×¢×¨×›×” ×—×œ×•×¤×™×ª',
    icon: 'ğŸ“Š',
    subcategories: [
      '×¨×•×‘×¨×™×§×” ×œ×”×¢×¨×›×”',
      '×¤×¨×•×™×§×˜ ××¡×›×',
      '×ª×™×§ ×¢×‘×•×“×•×ª (Portfolio)',
      '×”×¢×¨×›×ª ×¢××™×ª×™×'
    ]
  }
];

// Common field options for reuse
export const COMMON_FIELD_OPTIONS = {
  subjects: ['××ª××˜×™×§×”', '×¢×‘×¨×™×ª', '×× ×’×œ×™×ª', '××“×¢×™×', '×”×™×¡×˜×•×¨×™×”', '×’××•×’×¨×¤×™×”', '××–×¨×—×•×ª', '×ª× "×š', '×¡×¤×¨×•×ª', '××—×¨'],
  gradeLevels: ['××³', '×‘×³', '×’×³', '×“×³', '×”×³', '×•×³', '×–×³', '×—×³', '×˜×³', '×™×³', '×™×´×', '×™×´×‘'],
  difficultyLevels: ['×§×œ', '×‘×™× ×•× ×™', '×××ª×’×¨'],
  questionCounts: ['5', '10', '15', '20', '25', '30']
};

const PROMPTS_COLLECTION = 'prompts';
const RATINGS_COLLECTION = 'prompt_ratings';

// ============================================
// Prompt CRUD Operations
// ============================================

export async function createPrompt(prompt: Omit<Prompt, 'id' | 'createdAt' | 'usageCount' | 'averageRating' | 'ratingCount'>): Promise<string> {
  const docRef = await addDoc(collection(db, PROMPTS_COLLECTION), {
    ...prompt,
    createdAt: serverTimestamp(),
    usageCount: 0,
    averageRating: 0,
    ratingCount: 0,
    status: prompt.status || 'active'
  });
  return docRef.id;
}

export async function getPrompt(promptId: string): Promise<Prompt | null> {
  const docSnap = await getDoc(doc(db, PROMPTS_COLLECTION, promptId));
  if (!docSnap.exists()) return null;
  return { id: docSnap.id, ...docSnap.data() } as Prompt;
}

export async function updatePrompt(promptId: string, updates: Partial<Prompt>): Promise<void> {
  await updateDoc(doc(db, PROMPTS_COLLECTION, promptId), updates);
}

export async function deletePrompt(promptId: string): Promise<void> {
  await deleteDoc(doc(db, PROMPTS_COLLECTION, promptId));
}

// ============================================
// Fetching Prompts
// ============================================

export async function getAllPrompts(): Promise<Prompt[]> {
  // Simple query without orderBy to avoid needing composite index
  const q = query(
    collection(db, PROMPTS_COLLECTION),
    where('status', '==', 'active')
  );
  const snapshot = await getDocs(q);
  const prompts = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Prompt));

  // Sort client-side by createdAt descending
  return prompts.sort((a, b) => {
    const dateA = a.createdAt?.toDate?.() || new Date(0);
    const dateB = b.createdAt?.toDate?.() || new Date(0);
    return dateB.getTime() - dateA.getTime();
  });
}

export async function getPromptsByCategory(category: string): Promise<Prompt[]> {
  const q = query(
    collection(db, PROMPTS_COLLECTION),
    where('status', '==', 'active'),
    where('category', '==', category)
  );
  const snapshot = await getDocs(q);
  const prompts = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Prompt));

  // Sort client-side by createdAt descending
  return prompts.sort((a, b) => {
    const dateA = a.createdAt?.toDate?.() || new Date(0);
    const dateB = b.createdAt?.toDate?.() || new Date(0);
    return dateB.getTime() - dateA.getTime();
  });
}

export async function getFeaturedPrompt(): Promise<Prompt | null> {
  const q = query(
    collection(db, PROMPTS_COLLECTION),
    where('status', '==', 'active'),
    where('isFeatured', '==', true),
    limit(1)
  );
  const snapshot = await getDocs(q);
  if (snapshot.empty) {
    // Fallback: get highest rated prompt (fetch all active and sort client-side)
    const fallbackQ = query(
      collection(db, PROMPTS_COLLECTION),
      where('status', '==', 'active')
    );
    const fallbackSnapshot = await getDocs(fallbackQ);
    if (fallbackSnapshot.empty) return null;
    const prompts = fallbackSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Prompt));
    prompts.sort((a, b) => (b.averageRating || 0) - (a.averageRating || 0));
    return prompts[0];
  }
  return { id: snapshot.docs[0].id, ...snapshot.docs[0].data() } as Prompt;
}

export async function getTopRatedPrompts(limitCount: number = 10): Promise<Prompt[]> {
  const q = query(
    collection(db, PROMPTS_COLLECTION),
    where('status', '==', 'active')
  );
  const snapshot = await getDocs(q);
  const prompts = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Prompt));

  // Sort client-side by averageRating descending and limit
  return prompts
    .sort((a, b) => (b.averageRating || 0) - (a.averageRating || 0))
    .slice(0, limitCount);
}

export async function getMostUsedPrompts(limitCount: number = 10): Promise<Prompt[]> {
  const q = query(
    collection(db, PROMPTS_COLLECTION),
    where('status', '==', 'active')
  );
  const snapshot = await getDocs(q);
  const prompts = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Prompt));

  // Sort client-side by usageCount descending and limit
  return prompts
    .sort((a, b) => (b.usageCount || 0) - (a.usageCount || 0))
    .slice(0, limitCount);
}

export async function getPromptsByCreator(creatorId: string): Promise<Prompt[]> {
  const q = query(
    collection(db, PROMPTS_COLLECTION),
    where('createdBy', '==', creatorId)
  );
  const snapshot = await getDocs(q);
  const prompts = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Prompt));

  // Sort client-side by createdAt descending
  return prompts.sort((a, b) => {
    const dateA = a.createdAt?.toDate?.() || new Date(0);
    const dateB = b.createdAt?.toDate?.() || new Date(0);
    return dateB.getTime() - dateA.getTime();
  });
}

// Real-time subscription
export function subscribeToPrompts(
  callback: (prompts: Prompt[]) => void,
  category?: string
): () => void {
  let q;
  if (category) {
    q = query(
      collection(db, PROMPTS_COLLECTION),
      where('status', '==', 'active'),
      where('category', '==', category)
    );
  } else {
    q = query(
      collection(db, PROMPTS_COLLECTION),
      where('status', '==', 'active')
    );
  }

  return onSnapshot(q, (snapshot) => {
    const prompts = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Prompt));
    // Sort client-side by createdAt descending
    prompts.sort((a, b) => {
      const dateA = a.createdAt?.toDate?.() || new Date(0);
      const dateB = b.createdAt?.toDate?.() || new Date(0);
      return dateB.getTime() - dateA.getTime();
    });
    callback(prompts);
  });
}

// ============================================
// Usage Tracking
// ============================================

export async function trackPromptUsage(promptId: string): Promise<void> {
  await updateDoc(doc(db, PROMPTS_COLLECTION, promptId), {
    usageCount: increment(1)
  });
}

// ============================================
// Ratings System
// ============================================

export async function ratePrompt(
  promptId: string,
  odUseri: string,
  userName: string,
  rating: number,
  comment?: string
): Promise<void> {
  // Check if user already rated this prompt
  const existingRatingQuery = query(
    collection(db, RATINGS_COLLECTION),
    where('promptId', '==', promptId),
    where('userId', '==', odUseri)
  );
  const existingRating = await getDocs(existingRatingQuery);

  const batch = writeBatch(db);
  const promptRef = doc(db, PROMPTS_COLLECTION, promptId);

  if (!existingRating.empty) {
    // Update existing rating
    const oldRating = existingRating.docs[0].data().rating;
    const ratingRef = doc(db, RATINGS_COLLECTION, existingRating.docs[0].id);

    batch.update(ratingRef, {
      rating,
      comment: comment || null,
      createdAt: serverTimestamp()
    });

    // Update prompt's average (remove old, add new)
    const prompt = await getPrompt(promptId);
    if (prompt && prompt.ratingCount > 0) {
      const newTotal = (prompt.averageRating * prompt.ratingCount) - oldRating + rating;
      const newAverage = newTotal / prompt.ratingCount;
      batch.update(promptRef, {
        averageRating: newAverage
      });
    }
  } else {
    // Create new rating
    const newRatingRef = doc(collection(db, RATINGS_COLLECTION));
    batch.set(newRatingRef, {
      promptId,
      userId: odUseri,
      userName,
      rating,
      comment: comment || null,
      createdAt: serverTimestamp()
    });

    // Update prompt stats
    const prompt = await getPrompt(promptId);
    if (prompt) {
      const newCount = prompt.ratingCount + 1;
      const newAverage = ((prompt.averageRating * prompt.ratingCount) + rating) / newCount;
      batch.update(promptRef, {
        averageRating: newAverage,
        ratingCount: newCount
      });
    }
  }

  await batch.commit();
}

export async function getPromptRatings(promptId: string): Promise<PromptRating[]> {
  const q = query(
    collection(db, RATINGS_COLLECTION),
    where('promptId', '==', promptId)
  );
  const snapshot = await getDocs(q);
  const ratings = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as PromptRating));

  // Sort client-side by createdAt descending
  return ratings.sort((a, b) => {
    const dateA = a.createdAt?.toDate?.() || new Date(0);
    const dateB = b.createdAt?.toDate?.() || new Date(0);
    return dateB.getTime() - dateA.getTime();
  });
}

export async function getUserRatingForPrompt(promptId: string, odUseri: string): Promise<PromptRating | null> {
  const q = query(
    collection(db, RATINGS_COLLECTION),
    where('promptId', '==', promptId),
    where('userId', '==', odUseri)
  );
  const snapshot = await getDocs(q);
  if (snapshot.empty) return null;
  return { id: snapshot.docs[0].id, ...snapshot.docs[0].data() } as PromptRating;
}

// ============================================
// Teacher Stats (for "Recommended Teacher" badge)
// ============================================

export async function getTeacherStats(odUseri: string): Promise<TeacherStats> {
  const prompts = await getPromptsByCreator(odUseri);

  const totalRatings = prompts.reduce((sum, p) => sum + p.ratingCount, 0);
  const weightedSum = prompts.reduce((sum, p) => sum + (p.averageRating * p.ratingCount), 0);
  const averageRating = totalRatings > 0 ? weightedSum / totalRatings : 0;

  return {
    odUseri,
    promptCount: prompts.length,
    averageRating,
    totalRatings,
    isRecommended: averageRating >= 4.5 && prompts.length >= 5
  };
}

export async function isTeacherRecommended(odUseri: string): Promise<boolean> {
  const stats = await getTeacherStats(odUseri);
  return stats.isRecommended;
}

// ============================================
// Helper: Fill prompt template with values
// ============================================

export function fillPromptTemplate(template: string, fieldValues: Record<string, string>): string {
  let result = template;
  for (const [key, value] of Object.entries(fieldValues)) {
    const regex = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
    result = result.replace(regex, value || '___');
  }
  return result;
}

// ============================================
// Search
// ============================================

export async function searchPrompts(searchTerm: string): Promise<Prompt[]> {
  // Firestore doesn't support full-text search, so we fetch all and filter client-side
  // For production, consider Algolia or Elasticsearch
  const allPrompts = await getAllPrompts();
  const lowerSearch = searchTerm.toLowerCase();

  return allPrompts.filter(prompt =>
    prompt.title.toLowerCase().includes(lowerSearch) ||
    prompt.description.toLowerCase().includes(lowerSearch) ||
    prompt.category.toLowerCase().includes(lowerSearch) ||
    prompt.subcategory.toLowerCase().includes(lowerSearch)
  );
}

// ============================================
// Bulk create (for initial seeding)
// ============================================

export async function bulkCreatePrompts(prompts: Omit<Prompt, 'id' | 'createdAt' | 'usageCount' | 'averageRating' | 'ratingCount'>[]): Promise<string[]> {
  const batch = writeBatch(db);
  const ids: string[] = [];

  // Firestore batch limit is 500, so we need to split
  const chunks = [];
  for (let i = 0; i < prompts.length; i += 400) {
    chunks.push(prompts.slice(i, i + 400));
  }

  for (const chunk of chunks) {
    const chunkBatch = writeBatch(db);
    for (const prompt of chunk) {
      const docRef = doc(collection(db, PROMPTS_COLLECTION));
      ids.push(docRef.id);
      chunkBatch.set(docRef, {
        ...prompt,
        createdAt: serverTimestamp(),
        usageCount: 0,
        averageRating: 0,
        ratingCount: 0,
        status: 'active'
      });
    }
    await chunkBatch.commit();
  }

  return ids;
}
