/**
 * MCP Tools for Curriculum Agent
 *
 * These tools wrap the existing pipeline (Architect -> Generator -> Guardian)
 * to be used by the Claude Agent SDK. The agent calls these tools, and the
 * tools execute the same code a teacher would trigger through the UI.
 *
 * IMPORTANT: The agent does NOT create content directly - all content is
 * generated by the existing pipeline with all its rules and constraints.
 */

import { getFirestore, Timestamp, FieldValue } from 'firebase-admin/firestore';
import { v4 as uuidv4 } from 'uuid';
import * as logger from 'firebase-functions/logger';

import { runExamArchitect, type ExamArchitectContext } from '../services/examArchitect';
import { generateExamQuestion, type ExamGeneratorContext, type ExamQuestionResponse } from '../services/examGenerator';
import { validateExamIntegrity, performLocalValidation, autoRepairExamQuestions, type ExamGuardianResult } from '../services/examGuardian';
import { mapSystemItemToBlock } from '../shared/utils/geminiParsers';

import type {
    CurriculumStandard,
    BankActivity,
    GuardianResult,
    ToolInput,
    ToolOutput,
    ActivitySubject,
    GradeLevel,
    QUALITY_THRESHOLDS
} from '../services/activityBank/types';
import type { ActivityBlockType, BloomLevel, ActivityBlockMetadata } from '../shared/types/courseTypes';

// ============================================
// Tool Schemas for Claude Agent SDK
// ============================================

export const MCPToolSchemas = [
    {
        name: 'load_curriculum_standards',
        description: 'Load relevant curriculum standards for Hebrew or Science grades 5-6. Use this first to understand what content should be created.',
        input_schema: {
            type: 'object',
            properties: {
                subject: {
                    type: 'string',
                    enum: ['hebrew', 'science'],
                    description: 'The subject area: hebrew (עברית) or science (מדעים)'
                },
                gradeLevel: {
                    type: 'string',
                    enum: ['ה', 'ו'],
                    description: 'The grade level: ה (5th) or ו (6th)'
                },
                topic: {
                    type: 'string',
                    description: 'Optional: specific topic to search for (e.g., "מערכת הדם", "הבנת הנקרא")'
                },
                bloomLevels: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'Optional: filter by Bloom levels'
                }
            },
            required: ['subject', 'gradeLevel']
        }
    },
    {
        name: 'search_existing_activities',
        description: 'Search for existing activities in the bank to avoid duplicates. Call this before generating new activities.',
        input_schema: {
            type: 'object',
            properties: {
                topic: {
                    type: 'string',
                    description: 'Topic to search for'
                },
                activityType: {
                    type: 'string',
                    description: 'Optional: filter by activity type'
                },
                bloomLevel: {
                    type: 'string',
                    description: 'Optional: filter by Bloom level'
                },
                gradeLevel: {
                    type: 'string',
                    enum: ['ה', 'ו'],
                    description: 'Grade level to search within'
                }
            },
            required: ['topic', 'gradeLevel']
        }
    },
    {
        name: 'generate_activity_skeleton',
        description: 'Generate the structure/skeleton for an activity based on a curriculum standard. This uses the Exam Architect service.',
        input_schema: {
            type: 'object',
            properties: {
                curriculumStandardId: {
                    type: 'string',
                    description: 'ID of the curriculum standard to base the activity on'
                },
                activityType: {
                    type: 'string',
                    description: 'Type of activity to create (e.g., multiple-choice, fill_in_blanks, ordering)'
                },
                bloomLevel: {
                    type: 'string',
                    description: 'Target Bloom level (knowledge, comprehension, application, analysis, synthesis, evaluation)'
                },
                difficultyLevel: {
                    type: 'string',
                    enum: ['easy', 'medium', 'hard'],
                    description: 'Difficulty level for the activity'
                }
            },
            required: ['curriculumStandardId', 'activityType', 'bloomLevel']
        }
    },
    {
        name: 'generate_activity_content',
        description: 'Generate full activity content from a skeleton. This uses the Exam Generator service with all linguistic constraints.',
        input_schema: {
            type: 'object',
            properties: {
                skeleton: {
                    type: 'object',
                    description: 'The activity skeleton from generate_activity_skeleton'
                },
                curriculumContext: {
                    type: 'string',
                    description: 'Curriculum context text to use for content generation'
                },
                gradeLevel: {
                    type: 'string',
                    description: 'Grade level for linguistic constraints'
                }
            },
            required: ['skeleton', 'curriculumContext', 'gradeLevel']
        }
    },
    {
        name: 'validate_activity',
        description: 'Validate activity quality using the Guardian service. This checks for biases, accessibility, and quality metrics.',
        input_schema: {
            type: 'object',
            properties: {
                activity: {
                    type: 'object',
                    description: 'The activity content to validate'
                },
                curriculumStandard: {
                    type: 'object',
                    description: 'The curriculum standard for alignment checking'
                },
                gradeLevel: {
                    type: 'string',
                    description: 'Grade level for validation'
                }
            },
            required: ['activity', 'curriculumStandard', 'gradeLevel']
        }
    },
    {
        name: 'save_to_activity_bank',
        description: 'Save a validated activity to the activity bank. Only call this after validation passes with score >= 60.',
        input_schema: {
            type: 'object',
            properties: {
                activity: {
                    type: 'object',
                    description: 'The validated activity content'
                },
                curriculumStandardId: {
                    type: 'string',
                    description: 'ID of the curriculum standard'
                },
                qualityScore: {
                    type: 'number',
                    description: 'Quality score from validation (0-100)'
                },
                guardianResult: {
                    type: 'object',
                    description: 'Full Guardian validation result'
                },
                metadata: {
                    type: 'object',
                    properties: {
                        subject: { type: 'string' },
                        gradeLevel: { type: 'string' },
                        topic: { type: 'string' },
                        bloomLevel: { type: 'string' },
                        learningObjectives: { type: 'array', items: { type: 'string' } }
                    },
                    required: ['subject', 'gradeLevel', 'topic', 'bloomLevel']
                }
            },
            required: ['activity', 'curriculumStandardId', 'qualityScore', 'guardianResult', 'metadata']
        }
    }
];

// ============================================
// Tool Implementations
// ============================================

export class MCPToolImplementations {
    private db = getFirestore();
    private openaiApiKey: string;

    constructor(openaiApiKey: string) {
        this.openaiApiKey = openaiApiKey;
    }

    /**
     * Load curriculum standards from Firestore
     * Supports semantic search if topic is provided
     */
    async loadCurriculumStandards(
        params: ToolInput['load_curriculum_standards']
    ): Promise<ToolOutput['load_curriculum_standards']> {
        logger.info('Tool: load_curriculum_standards', { params });

        let query = this.db.collection('curriculum_standards')
            .where('subject', '==', params.subject)
            .where('gradeLevel', '==', params.gradeLevel);

        const snapshot = await query.limit(50).get();
        let standards = snapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data()
        })) as CurriculumStandard[];

        // If topic provided, filter by keyword matching
        if (params.topic) {
            const topicWords = params.topic.toLowerCase().split(/\s+/);
            standards = standards.filter(s =>
                topicWords.some(word =>
                    s.topic.toLowerCase().includes(word) ||
                    s.title.toLowerCase().includes(word) ||
                    s.description.toLowerCase().includes(word)
                )
            );
        }

        // If bloom levels provided, filter
        if (params.bloomLevels && params.bloomLevels.length > 0) {
            standards = standards.filter(s =>
                s.recommendedBloomLevels.some(b => params.bloomLevels!.includes(b))
            );
        }

        logger.info(`Found ${standards.length} curriculum standards`);
        return standards.slice(0, 10); // Return top 10
    }

    /**
     * Search for existing activities to avoid duplicates
     */
    async searchExistingActivities(
        params: ToolInput['search_existing_activities']
    ): Promise<ToolOutput['search_existing_activities']> {
        logger.info('Tool: search_existing_activities', { params });

        let query = this.db.collection('activity_bank')
            .where('gradeLevel', '==', params.gradeLevel)
            .where('reviewStatus', 'in', ['auto_approved', 'approved']);

        if (params.activityType) {
            query = query.where('activityType', '==', params.activityType);
        }
        if (params.bloomLevel) {
            query = query.where('bloomLevel', '==', params.bloomLevel);
        }

        const snapshot = await query.limit(50).get();
        const activities = snapshot.docs.map(doc => doc.data() as BankActivity);

        // Filter by topic similarity using keywords
        const topicWords = params.topic.toLowerCase().split(/\s+/);
        const similar = activities.filter(a =>
            topicWords.some(word =>
                a.topic.toLowerCase().includes(word) ||
                a.searchKeywords.some(k => k.includes(word))
            )
        );

        logger.info(`Found ${similar.length} similar activities`);
        return {
            exists: similar.length > 0,
            similarActivities: similar.slice(0, 5)
        };
    }

    /**
     * Generate activity skeleton using the EXISTING Exam Architect
     * This ensures all architectural rules are followed
     */
    async generateActivitySkeleton(
        params: ToolInput['generate_activity_skeleton']
    ): Promise<ToolOutput['generate_activity_skeleton']> {
        logger.info('Tool: generate_activity_skeleton', { params });

        // Load curriculum standard
        const standardDoc = await this.db.collection('curriculum_standards')
            .doc(params.curriculumStandardId)
            .get();

        if (!standardDoc.exists) {
            throw new Error(`Curriculum standard not found: ${params.curriculumStandardId}`);
        }

        const standard = standardDoc.data() as CurriculumStandard;

        // Use EXISTING Exam Architect - same code that teachers use!
        const architectContext: ExamArchitectContext = {
            topic: standard.topic,
            gradeLevel: standard.gradeLevel,
            subject: standard.subject === 'hebrew' ? 'עברית' : 'מדעים',
            activityLength: 'short', // Single activity
            sourceText: `${standard.description}\n\nיעדי למידה:\n${standard.learningObjectives.join('\n')}`
        };

        const skeleton = await runExamArchitect(architectContext);

        if (!skeleton || !skeleton.steps || skeleton.steps.length === 0) {
            throw new Error('Architect failed to generate skeleton');
        }

        // Return the first step adapted for our needs
        const step = skeleton.steps[0];

        return {
            ...step,
            curriculumStandard: standard,
            suggested_interaction_type: params.activityType,
            bloom_level: params.bloomLevel,
            difficulty_level: params.difficultyLevel || 'medium'
        };
    }

    /**
     * Generate activity content using the EXISTING Exam Generator
     * This ensures all linguistic constraints and rules are followed
     */
    async generateActivityContent(
        params: ToolInput['generate_activity_content']
    ): Promise<ToolOutput['generate_activity_content']> {
        logger.info('Tool: generate_activity_content', { params });

        // Use EXISTING Exam Generator - same code that teachers use!
        const generatorContext: ExamGeneratorContext = {
            topic: params.skeleton.title || params.skeleton.curriculumStandard?.topic || 'פעילות לימודית',
            gradeLevel: params.gradeLevel,
            sourceText: params.curriculumContext
        };

        const content = await generateExamQuestion(params.skeleton, generatorContext);

        if (!content) {
            throw new Error('Generator failed to create content');
        }

        return content;
    }

    /**
     * Validate activity using the EXISTING Exam Guardian
     * This ensures all quality, bias, and accessibility checks are performed
     */
    async validateActivity(
        params: ToolInput['validate_activity']
    ): Promise<ToolOutput['validate_activity']> {
        logger.info('Tool: validate_activity', { params });

        // Use EXISTING Guardian - same validation teachers' content goes through!

        // First, local validation (fast checks)
        const localValidation = performLocalValidation([params.activity]);
        logger.info(`Local validation: ${localValidation.passed ? 'PASSED' : 'ISSUES FOUND'}`);

        // Auto-repair common issues
        const repaired = autoRepairExamQuestions([params.activity]);

        // Full AI Guardian validation
        const guardianResult = await validateExamIntegrity(repaired);

        logger.info(`Guardian result: ${guardianResult.status}, score: ${guardianResult.overall_quality_score}`);

        return guardianResult as GuardianResult;
    }

    /**
     * Save validated activity to the Activity Bank
     * Enforces quality thresholds before saving
     */
    async saveToActivityBank(
        params: ToolInput['save_to_activity_bank']
    ): Promise<ToolOutput['save_to_activity_bank']> {
        logger.info('Tool: save_to_activity_bank', { qualityScore: params.qualityScore });

        // Enforce minimum quality threshold
        if (params.qualityScore < 60) {
            logger.warn('Activity quality too low, not saving');
            throw new Error(`Activity quality score (${params.qualityScore}) is below minimum threshold (60)`);
        }

        // Determine review status based on quality
        let reviewStatus: 'auto_approved' | 'pending_review' | 'rejected';
        if (params.qualityScore >= 80 && params.guardianResult.status === 'PASS') {
            reviewStatus = 'auto_approved';
        } else if (params.qualityScore >= 60 || params.guardianResult.status === 'WARNING') {
            reviewStatus = 'pending_review';
        } else {
            reviewStatus = 'rejected';
        }

        const activityId = uuidv4();

        // Map the activity to block format
        const block = mapSystemItemToBlock(params.activity);
        if (!block) {
            throw new Error('Failed to map activity to block format');
        }

        // Extract keywords from activity content
        const searchKeywords = this.extractKeywords(params.activity);
        const tags = this.extractTags(params.activity, params.metadata.bloomLevel);

        const bankActivity: Partial<BankActivity> = {
            id: activityId,
            version: 1,

            // Classification
            subject: params.metadata.subject as ActivitySubject,
            gradeLevel: params.metadata.gradeLevel as GradeLevel,
            topic: params.metadata.topic,
            curriculumStandardId: params.curriculumStandardId,

            // Content
            activityType: block.type,
            content: block.content,
            metadata: (block.metadata || { bloomLevel: params.metadata.bloomLevel as BloomLevel, score: 10 }) as ActivityBlockMetadata,
            bloomLevel: params.metadata.bloomLevel as BloomLevel,
            learningObjectives: params.metadata.learningObjectives || [],

            // Quality
            qualityScore: params.qualityScore,
            guardianResult: params.guardianResult,
            reviewStatus,

            // Generation Metadata
            generatedBy: 'claude_agent',
            generationModel: 'claude-opus-4-5',

            // Usage Tracking
            usageCount: 0,
            averageRating: 0,
            ratingCount: 0,
            copiedToCoursesCount: 0,

            // Timestamps
            createdAt: Timestamp.now(),
            updatedAt: Timestamp.now(),
            createdBy: 'system',

            // Discovery
            tags,
            searchKeywords,
            isFeatured: false
        };

        await this.db.collection('activity_bank').doc(activityId).set(bankActivity);

        logger.info(`Activity saved to bank: ${activityId}, status: ${reviewStatus}`);

        return { success: true, activityId };
    }

    // ============================================
    // Helper Methods
    // ============================================

    private extractKeywords(activity: any): string[] {
        const text = JSON.stringify(activity.data || activity || {});
        // Extract Hebrew words
        const hebrewWords = text.match(/[\u0590-\u05FF]+/g) || [];
        // Remove duplicates and limit
        return [...new Set(hebrewWords)]
            .filter(w => w.length > 2)
            .slice(0, 30);
    }

    private extractTags(activity: any, bloomLevel: string): string[] {
        const tags: string[] = [];

        if (bloomLevel) {
            tags.push(bloomLevel);
        }

        const type = activity.selected_interaction ||
            activity.suggested_interaction_type ||
            activity.type;
        if (type) {
            tags.push(type);
        }

        const difficulty = activity.data?.difficulty_level ||
            activity.difficulty_level;
        if (difficulty) {
            tags.push(difficulty);
        }

        return tags;
    }
}

// ============================================
// Tool Executor
// ============================================

export async function executeToolCall(
    tools: MCPToolImplementations,
    toolName: string,
    input: any
): Promise<any> {
    logger.info(`Executing tool: ${toolName}`);

    switch (toolName) {
        case 'load_curriculum_standards':
            return await tools.loadCurriculumStandards(input);

        case 'search_existing_activities':
            return await tools.searchExistingActivities(input);

        case 'generate_activity_skeleton':
            return await tools.generateActivitySkeleton(input);

        case 'generate_activity_content':
            return await tools.generateActivityContent(input);

        case 'validate_activity':
            return await tools.validateActivity(input);

        case 'save_to_activity_bank':
            return await tools.saveToActivityBank(input);

        default:
            throw new Error(`Unknown tool: ${toolName}`);
    }
}
