{"version":3,"file":"multimodalService-BOWYif01.js","sources":["../../src/services/multimodalService.ts"],"sourcesContent":["import { transcribeAudio as transcribeAudioViaProxy } from './ai/geminiApi';\r\nimport { functions } from '../firebase';\r\nimport { httpsCallable } from 'firebase/functions';\r\n\r\n// Error codes matching backend\r\nexport const TRANSCRIPTION_ERROR_CODES = {\r\n    NO_CAPTIONS: 'NO_CAPTIONS',\r\n    PRIVATE_VIDEO: 'PRIVATE_VIDEO',\r\n    VIDEO_NOT_FOUND: 'VIDEO_NOT_FOUND',\r\n    RATE_LIMITED: 'RATE_LIMITED',\r\n    NETWORK_ERROR: 'NETWORK_ERROR',\r\n    WHISPER_FAILED: 'WHISPER_FAILED',\r\n    INVALID_URL: 'INVALID_URL',\r\n    UNKNOWN: 'UNKNOWN'\r\n} as const;\r\n\r\nexport type TranscriptionErrorCode = typeof TRANSCRIPTION_ERROR_CODES[keyof typeof TRANSCRIPTION_ERROR_CODES];\r\n\r\nexport interface TranscriptionError extends Error {\r\n    code: TranscriptionErrorCode;\r\n    userMessage: string;\r\n}\r\n\r\nexport interface TranscriptionResult {\r\n    text: string;\r\n    metadata?: {\r\n        source: 'captions' | 'whisper';\r\n        originalLanguage: string;\r\n        wasTranslated: boolean;\r\n        characterCount: number;\r\n    };\r\n}\r\n\r\n// Helper to create typed errors\r\nfunction createTranscriptionError(code: TranscriptionErrorCode, userMessage: string): TranscriptionError {\r\n    const error = new Error(userMessage) as TranscriptionError;\r\n    error.code = code;\r\n    error.userMessage = userMessage;\r\n    return error;\r\n}\r\n\r\n// Helper to extract error details from Firebase error\r\nfunction parseFirebaseError(error: any): { code: TranscriptionErrorCode; userMessage: string } {\r\n    // Firebase HttpsError format\r\n    if (error?.details?.code) {\r\n        return {\r\n            code: error.details.code as TranscriptionErrorCode,\r\n            userMessage: error.details.userMessage || '×©×’×™××” ×‘×ª××œ×•×œ ×”×¡×¨×˜×•×Ÿ'\r\n        };\r\n    }\r\n\r\n    // Check error message for common issues\r\n    const msg = error?.message?.toLowerCase() || '';\r\n\r\n    if (msg.includes('private') || msg.includes('permission')) {\r\n        return {\r\n            code: TRANSCRIPTION_ERROR_CODES.PRIVATE_VIDEO,\r\n            userMessage: '×”×¡×¨×˜×•×Ÿ ×¤×¨×˜×™ ×•×œ× × ×™×ª×Ÿ ×œ×’×©×ª ××œ×™×•'\r\n        };\r\n    }\r\n\r\n    if (msg.includes('not found') || msg.includes('unavailable') || msg.includes('404')) {\r\n        return {\r\n            code: TRANSCRIPTION_ERROR_CODES.VIDEO_NOT_FOUND,\r\n            userMessage: '×”×¡×¨×˜×•×Ÿ ×œ× × ××¦× ××• ×©×”×•×¡×¨'\r\n        };\r\n    }\r\n\r\n    if (msg.includes('rate') || msg.includes('429') || msg.includes('quota')) {\r\n        return {\r\n            code: TRANSCRIPTION_ERROR_CODES.RATE_LIMITED,\r\n            userMessage: '×™×•×ª×¨ ××“×™ ×‘×§×©×•×ª. × ×¡×• ×©×•×‘ ×‘×¢×•×“ ×“×§×”.'\r\n        };\r\n    }\r\n\r\n    if (msg.includes('timeout') || msg.includes('network') || msg.includes('fetch')) {\r\n        return {\r\n            code: TRANSCRIPTION_ERROR_CODES.NETWORK_ERROR,\r\n            userMessage: '×‘×¢×™×™×ª ×¨×©×ª. ×‘×“×§×• ××ª ×”×—×™×‘×•×¨ ×•× ×¡×• ×©×•×‘.'\r\n        };\r\n    }\r\n\r\n    if (msg.includes('caption') || msg.includes('subtitle') || msg.includes('transcript')) {\r\n        return {\r\n            code: TRANSCRIPTION_ERROR_CODES.NO_CAPTIONS,\r\n            userMessage: '×œ×¡×¨×˜×•×Ÿ ××™×Ÿ ×›×ª×•×‘×™×•×ª ×–××™× ×•×ª. × ×¡×• ×œ×”×¢×ª×™×§ ××ª ×”×ª××œ×™×œ ×™×“× ×™×ª ××™×•×˜×™×•×‘.'\r\n        };\r\n    }\r\n\r\n    return {\r\n        code: TRANSCRIPTION_ERROR_CODES.UNKNOWN,\r\n        userMessage: '×©×’×™××” ×‘×ª××œ×•×œ ×”×¡×¨×˜×•×Ÿ. × ×¡×• ×©×•×‘ ××• ×”×¢×ª×™×§×• ××ª ×”×ª××œ×™×œ ×™×“× ×™×ª.'\r\n    };\r\n}\r\n\r\nexport const MultimodalService = {\r\n    /**\r\n     * Transcribes an audio file using OpenAI Whisper via secure proxy.\r\n     * @param file - The audio file (mp3, wav, etc.)\r\n     * @returns The transcribed text.\r\n     */\r\n    transcribeAudio: async (file: File): Promise<string | null> => {\r\n        try {\r\n            // Validate file size (Whisper limit is 25MB)\r\n            if (file.size > 25 * 1024 * 1024) {\r\n                console.error(\"Audio file too large:\", file.size);\r\n                throw createTranscriptionError(\r\n                    TRANSCRIPTION_ERROR_CODES.UNKNOWN,\r\n                    '×§×•×‘×¥ ×”××•×“×™×• ×’×“×•×œ ××“×™ (××§×¡×™××•× 25MB)'\r\n                );\r\n            }\r\n\r\n            // Use secure proxy instead of direct API call\r\n            const result = await transcribeAudioViaProxy(file);\r\n            return result;\r\n        } catch (e: any) {\r\n            console.error(\"Transcription failed:\", e);\r\n\r\n            // Re-throw if already a TranscriptionError\r\n            if (e.code && e.userMessage) {\r\n                throw e;\r\n            }\r\n\r\n            throw createTranscriptionError(\r\n                TRANSCRIPTION_ERROR_CODES.WHISPER_FAILED,\r\n                '×ª××œ×•×œ ×”×§×•×‘×¥ × ×›×©×œ. × ×¡×• ×§×•×‘×¥ ××—×¨ ××• ×¤×•×¨××˜ ××—×¨.'\r\n            );\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Validates a YouTube URL and extracts the video ID.\r\n     * @param url - YouTube video URL\r\n     * @returns Video ID or null if invalid.\r\n     */\r\n    validateYouTubeUrl: (url: string): string | null => {\r\n        if (!url || typeof url !== 'string') return null;\r\n\r\n        // Clean the URL\r\n        const cleanUrl = url.trim();\r\n\r\n        // Multiple regex patterns to catch various YouTube URL formats\r\n        const patterns = [\r\n            /(?:youtube\\.com\\/watch\\?v=|youtu\\.be\\/|youtube\\.com\\/embed\\/|youtube\\.com\\/v\\/|youtube\\.com\\/shorts\\/)([a-zA-Z0-9_-]{11})/,\r\n            /^([a-zA-Z0-9_-]{11})$/ // Just the video ID\r\n        ];\r\n\r\n        for (const pattern of patterns) {\r\n            const match = cleanUrl.match(pattern);\r\n            if (match && match[1]) {\r\n                return match[1];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Calls the backend function to transcribe a YouTube video.\r\n     * Uses multiple strategies: YouTube captions â†’ Whisper fallback â†’ Translation\r\n     *\r\n     * @param url - Valid YouTube URL\r\n     * @returns TranscriptionResult with text and metadata\r\n     * @throws TranscriptionError with specific error code and user message\r\n     */\r\n    processYoutubeUrl: async (url: string): Promise<TranscriptionResult> => {\r\n        // Validate URL first\r\n        const videoId = MultimodalService.validateYouTubeUrl(url);\r\n        if (!videoId) {\r\n            throw createTranscriptionError(\r\n                TRANSCRIPTION_ERROR_CODES.INVALID_URL,\r\n                '×”×§×™×©×•×¨ ×©×”×–× ×ª ×œ× ×ª×§×™×Ÿ. ×•×•×“××• ×©×–×” ×§×™×©×•×¨ ×œ×™×•×˜×™×•×‘.'\r\n            );\r\n        }\r\n\r\n        try {\r\n            console.log(`ğŸ¬ Processing YouTube video: ${videoId}`);\r\n\r\n            const transcribeFn = httpsCallable(functions, 'transcribeYoutube', {\r\n                timeout: 300000 // 5 minute timeout to match backend\r\n            });\r\n\r\n            // Send videoId AND url (backup)\r\n            const result = await transcribeFn({ videoId, url });\r\n\r\n            const data = result.data as TranscriptionResult;\r\n\r\n            // Validate response\r\n            if (!data?.text || data.text.length < 10) {\r\n                throw createTranscriptionError(\r\n                    TRANSCRIPTION_ERROR_CODES.NO_CAPTIONS,\r\n                    '×œ× ×”×¦×œ×—× ×• ×œ×—×œ×¥ ×˜×§×¡×˜ ××”×¡×¨×˜×•×Ÿ. × ×¡×• ×œ×”×¢×ª×™×§ ××ª ×”×ª××œ×™×œ ×™×“× ×™×ª ××™×•×˜×™×•×‘.'\r\n                );\r\n            }\r\n\r\n            console.log(`âœ… Transcription successful: ${data.text.length} characters`);\r\n\r\n            // Log metadata if available\r\n            if (data.metadata) {\r\n                console.log(`ğŸ“Š Source: ${data.metadata.source}, Translated: ${data.metadata.wasTranslated}`);\r\n            }\r\n\r\n            return data;\r\n\r\n        } catch (e: any) {\r\n            console.error(\"YouTube processing failed:\", e);\r\n\r\n            // Re-throw if already a TranscriptionError\r\n            if (e.code && e.userMessage) {\r\n                throw e;\r\n            }\r\n\r\n            // Parse Firebase error\r\n            const { code, userMessage } = parseFirebaseError(e);\r\n            throw createTranscriptionError(code, userMessage);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Get user-friendly error message for display\r\n     */\r\n    getErrorMessage: (error: any): string => {\r\n        if (error?.userMessage) {\r\n            return error.userMessage;\r\n        }\r\n\r\n        const { userMessage } = parseFirebaseError(error);\r\n        return userMessage;\r\n    },\r\n\r\n    /**\r\n     * Check if error is retryable\r\n     */\r\n    isRetryableError: (error: any): boolean => {\r\n        const code = error?.code || parseFirebaseError(error).code;\r\n\r\n        return [\r\n            TRANSCRIPTION_ERROR_CODES.NETWORK_ERROR,\r\n            TRANSCRIPTION_ERROR_CODES.RATE_LIMITED,\r\n            TRANSCRIPTION_ERROR_CODES.UNKNOWN\r\n        ].includes(code);\r\n    }\r\n};\r\n"],"names":["TRANSCRIPTION_ERROR_CODES","createTranscriptionError","code","userMessage","error","parseFirebaseError","_a","msg","_b","MultimodalService","file","transcribeAudioViaProxy","url","cleanUrl","patterns","pattern","match","videoId","data","httpsCallable","functions","e"],"mappings":"uDAKO,MAAMA,EAA4B,CACrC,YAAa,cACb,cAAe,gBACf,gBAAiB,kBACjB,aAAc,eACd,cAAe,gBACf,eAAgB,iBAChB,YAAa,cACb,QAAS,SACb,EAoBA,SAASC,EAAyBC,EAA8BC,EAAyC,CACrG,MAAMC,EAAQ,IAAI,MAAMD,CAAW,EACnC,OAAAC,EAAM,KAAOF,EACbE,EAAM,YAAcD,EACbC,CACX,CAGA,SAASC,EAAmBD,EAAmE,SAE3F,IAAIE,EAAAF,GAAA,YAAAA,EAAO,UAAP,MAAAE,EAAgB,KAChB,MAAO,CACH,KAAMF,EAAM,QAAQ,KACpB,YAAaA,EAAM,QAAQ,aAAe,qBAAA,EAKlD,MAAMG,IAAMC,EAAAJ,GAAA,YAAAA,EAAO,UAAP,YAAAI,EAAgB,gBAAiB,GAE7C,OAAID,EAAI,SAAS,SAAS,GAAKA,EAAI,SAAS,YAAY,EAC7C,CACH,KAAMP,EAA0B,cAChC,YAAa,gCAAA,EAIjBO,EAAI,SAAS,WAAW,GAAKA,EAAI,SAAS,aAAa,GAAKA,EAAI,SAAS,KAAK,EACvE,CACH,KAAMP,EAA0B,gBAChC,YAAa,yBAAA,EAIjBO,EAAI,SAAS,MAAM,GAAKA,EAAI,SAAS,KAAK,GAAKA,EAAI,SAAS,OAAO,EAC5D,CACH,KAAMP,EAA0B,aAChC,YAAa,mCAAA,EAIjBO,EAAI,SAAS,SAAS,GAAKA,EAAI,SAAS,SAAS,GAAKA,EAAI,SAAS,OAAO,EACnE,CACH,KAAMP,EAA0B,cAChC,YAAa,qCAAA,EAIjBO,EAAI,SAAS,SAAS,GAAKA,EAAI,SAAS,UAAU,GAAKA,EAAI,SAAS,YAAY,EACzE,CACH,KAAMP,EAA0B,YAChC,YAAa,gEAAA,EAId,CACH,KAAMA,EAA0B,QAChC,YAAa,yDAAA,CAErB,CAEO,MAAMS,EAAoB,CAM7B,gBAAiB,MAAOC,GAAuC,CAC3D,GAAI,CAEA,GAAIA,EAAK,KAAO,GAAK,KAAO,KACxB,cAAQ,MAAM,wBAAyBA,EAAK,IAAI,EAC1CT,EACFD,EAA0B,QAC1B,qCAAA,EAMR,OADe,MAAMW,EAAwBD,CAAI,CAErD,OAAS,EAAQ,CAIb,MAHA,QAAQ,MAAM,wBAAyB,CAAC,EAGpC,EAAE,MAAQ,EAAE,YACN,EAGJT,EACFD,EAA0B,eAC1B,8CAAA,CAER,CACJ,EAOA,mBAAqBY,GAA+B,CAChD,GAAI,CAACA,GAAO,OAAOA,GAAQ,SAAU,OAAO,KAG5C,MAAMC,EAAWD,EAAI,KAAA,EAGfE,EAAW,CACb,4HACA,uBAAA,EAGJ,UAAWC,KAAWD,EAAU,CAC5B,MAAME,EAAQH,EAAS,MAAME,CAAO,EACpC,GAAIC,GAASA,EAAM,CAAC,EAChB,OAAOA,EAAM,CAAC,CAEtB,CAEA,OAAO,IACX,EAUA,kBAAmB,MAAOJ,GAA8C,CAEpE,MAAMK,EAAUR,EAAkB,mBAAmBG,CAAG,EACxD,GAAI,CAACK,EACD,MAAMhB,EACFD,EAA0B,YAC1B,gDAAA,EAIR,GAAI,CACA,QAAQ,IAAI,gCAAgCiB,CAAO,EAAE,EASrD,MAAMC,GAFS,MALMC,EAAcC,EAAW,oBAAqB,CAC/D,QAAS,GAAA,CACZ,EAGiC,CAAE,QAAAH,EAAS,IAAAL,EAAK,GAE9B,KAGpB,GAAI,EAACM,GAAA,MAAAA,EAAM,OAAQA,EAAK,KAAK,OAAS,GAClC,MAAMjB,EACFD,EAA0B,YAC1B,kEAAA,EAIR,eAAQ,IAAI,+BAA+BkB,EAAK,KAAK,MAAM,aAAa,EAGpEA,EAAK,UACL,QAAQ,IAAI,cAAcA,EAAK,SAAS,MAAM,iBAAiBA,EAAK,SAAS,aAAa,EAAE,EAGzFA,CAEX,OAASG,EAAQ,CAIb,GAHA,QAAQ,MAAM,6BAA8BA,CAAC,EAGzCA,EAAE,MAAQA,EAAE,YACZ,MAAMA,EAIV,KAAM,CAAE,KAAAnB,EAAM,YAAAC,GAAgBE,EAAmBgB,CAAC,EAClD,MAAMpB,EAAyBC,EAAMC,CAAW,CACpD,CACJ,EAKA,gBAAkBC,GAAuB,CACrC,GAAIA,GAAA,MAAAA,EAAO,YACP,OAAOA,EAAM,YAGjB,KAAM,CAAE,YAAAD,CAAA,EAAgBE,EAAmBD,CAAK,EAChD,OAAOD,CACX,EAKA,iBAAmBC,GAAwB,CACvC,MAAMF,GAAOE,GAAA,YAAAA,EAAO,OAAQC,EAAmBD,CAAK,EAAE,KAEtD,MAAO,CACHJ,EAA0B,cAC1BA,EAA0B,aAC1BA,EAA0B,OAAA,EAC5B,SAASE,CAAI,CACnB,CACJ"}